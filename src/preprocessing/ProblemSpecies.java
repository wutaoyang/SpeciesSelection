package preprocessing;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import speciesselection.MinSpecSetFamily;
import speciesselection.ReadFile;
import speciesselection.SpecSelException;
import speciesselection.SpeciesSelection;

/**
 * Identifies list of species that cause faster than exponential growth in
 * solving time for a species selection dataset
 *
 * @author mre16utu
 */
public class ProblemSpecies implements Runnable {

    private final PropertyChangeSupport pcs;
    private final ArrayList<Integer> probSpecies;
    private final File file;
    private final FileList fileList;// list of files created by this class
    private final int initialNoSpecies, expMarginPct;
    private final PlotPoints points;
    private final Options option;
    private boolean insufficient, finished;
    
    /**
     * Constructor
     * @param file
     * @param initialNoSpecies
     * @param expMarginPct
     * @param option
     * @throws FileNotFoundException 
     */
    public ProblemSpecies(File file, int initialNoSpecies, int expMarginPct, Options option) 
                                                throws FileNotFoundException {
        this.initialNoSpecies = initialNoSpecies;
        this.file         = file;
        this.expMarginPct = expMarginPct;
        this.option       = option;
        this.insufficient = false;
        this.finished     = false;
        this.points       = new PlotPoints();
        this.probSpecies  = new ArrayList<>();
        this.fileList     = new FileList();
        this.pcs          = new PropertyChangeSupport(this);
    }
    
    /**
     * Makes ProblemSpecies runnable on its own thread
     */
    @Override
    public void run() {
        try 
        {
            findProblemSpecies(file, initialNoSpecies, expMarginPct);
        } 
        catch (FileNotFoundException | InterruptedException ex) {
            Logger.getLogger(ProblemSpecies.class.getName()).log(Level.SEVERE, null, ex);
        }
        catch(SpecSelException ex)
        {
            ReadFile.infoBox(ex.toString(), "ProblemSpecies error");
            Logger.getLogger(ProblemSpecies.class.getName()).log(Level.SEVERE, null, ex);
        }
        setFinished();        
    }
    
    /**
     * Sets the status of the problem species identification process to finished 
     * and fires a property change event
     */
    private void setFinished()
    {
        finished = true;
        pcs.firePropertyChange("finished", null, finished);
    }
    
    /**
     * physically deletes all files in the fileList from the system. These are 
     * only files created by the program - i.e. subset and results files
     */
    public void deleteFiles()
    {
        fileList.delete();
    }
    
    /**
     * Allows checking whether or not identification of problem species is complete
     * @return 
     */
    public boolean isFinished() {
        return finished;
    }
    
    /**
     * returns read only version of the problem species list
     * @return 
     */
    public List<Integer> getProblemSpecies()
    {
        return Collections.unmodifiableList(probSpecies);
    }
    
    /**
     * returns PlotPoints
     * @return 
     */
    public PlotPoints getPoints()
    {
        return points;
    }
    
    /**
     * adds integer to problem species list and fires property change event
     * @param i 
     */
    private void addProbSpecies(int i)
    {
        probSpecies.add(i);
        pcs.firePropertyChange("size", null, probSpecies.size());
    }
    
    /**
     * allows adding a property change listener to monitor for changes to the problem species list
     * @param listener 
     */
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        pcs.addPropertyChangeListener(listener);
    }
    
    /**
     * Allows removal of listener
     * @param listener 
     */
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        pcs.removePropertyChangeListener(listener);
    }

    /**
     * This is the primary method of this class. It generates an initial subset 
     * of species from the file provide and the initial subset size specified. 
     * It runs 3 initial species selections, adding a species to the file to be 
     * processed on each occassion, so that we have some data points to fit an 
     * exponential curve to. The plot points have an X value being the subset 
     * size, and Y value being the MinSpecSetFamily size generated by SpecSel. 
     * It then continues adding one species at a time and running species 
     * selection. The MSSF size is compared to the expected value from the 
     * fitted exp curve. If MSSF size exceeds the fitted curve expectation by 
     * more than the specified margin, the last species added is considered a 
     * problem species and added to the list. That species is then excluded from 
     * further subsets. In this way, we identify the species that cause long 
     * processing times when standard Species Selection fails to compute a 
     * result within a reasonable time frame.
     * @param file
     * @param initialNoSpecies
     * @param expMarginPct
     * @throws FileNotFoundException
     * @throws InterruptedException 
     */
    private void findProblemSpecies(File file, int initialNoSpecies, int expMarginPct) 
            throws FileNotFoundException, InterruptedException, SpecSelException {
        long startPsTime = System.currentTimeMillis();
        List<String> fileAsList = FileUtils.readFileToList(file);
        // get number of species in the datafile
        int numSpecies  = fileAsList.size();
        // get full name of the file
        String fileName = file.getName();
        // get the extension of the file, e.g. .txt
        String fileExt  = fileName.substring(fileName.lastIndexOf("."));
        // get the name of the file excluded extension
        fileName = fileName.substring(0, fileName.lastIndexOf("."));

        if (numSpecies - initialNoSpecies > PlotPoints.MIN_POINTS_TO_FIT_CURVE) 
        {
            for (int i = initialNoSpecies; i < numSpecies; i++) {
                String tempFileName = fileName + "_" + i + fileExt;
                System.out.println(tempFileName);
                PrintWriter out = new PrintWriter(tempFileName);
                String str = "";
                int currentSpecies = -1;
                for (int j = 0; j <= i; j++) {
                    // get jth line from dataset
                    str = fileAsList.get(j);
                    // get species number from the jth line 
                    currentSpecies = Integer.parseInt(str.replaceFirst(".*?(\\d+).*", "$1"));
                    // check if species is problem species or not                    
                    if(!probSpecies.contains(currentSpecies))
                    {
                        //add species to latest file
                        out.println(str);
                    }
                }
                out.flush();
                out.close();
                fileList.add(new File(tempFileName));
                
                String[] args = {tempFileName};
                int truncateThreshold = 3;
                // run with truncated results to reduce processing time (allResults = false)
                SpeciesSelection specSel = new SpeciesSelection(tempFileName, false, truncateThreshold, "A", 0, 0, 0);
                long startTime = System.nanoTime();
                MinSpecSetFamily mssf = specSel.getMssf();
                int mssfSize = mssf.size();
                long totalTimeMs = (System.nanoTime() - startTime) / 1000000;
                System.out.println("File: " + tempFileName + ", took: " + totalTimeMs + "ms");

                // produce output if requested
                if(option == Options.ALL || (i == numSpecies - 1 && option == Options.FINAL))
                {
                    specSel.outputResults(mssf, tempFileName, truncateThreshold, "");
                    fileList.add(new File(specSel.getResultsFileName()));
                }
                                
                // add new point to plot points list
                points.addPoint(i - probSpecies.size(), mssfSize, tempFileName, currentSpecies, totalTimeMs);
                               
                // once enough initial points are generated to fit an exponential 
                // curve, begin checking if the last point added is within limits
                if (points.size() > PlotPoints.MIN_POINTS_TO_FIT_CURVE) {
                    if (!withinExpMargin(expMarginPct)) {
                        System.err.println("Problem Species: " + currentSpecies);
                        this.addProbSpecies(currentSpecies);
                    }
                }
            }
            System.out.println("Points:\n" + points);
            System.out.println("Problem Species Time Taken: " + (System.currentTimeMillis() - startPsTime)/3600000.0 + " hours");
        } else {
            System.out.println("Insufficient Species");
            insufficient = true;
        }
    }
    
    /**
     * checks if last point in the arrays is within the acceptable margin of an exponential fitted curve
     * @param expMarginPct
     * @return 
     */
    private boolean withinExpMargin(int expMarginPct) {
        return points.getLastMargin() < (1 + (expMarginPct / 100.0));
    }

    /**
     * Converts a list of strings to a single string separated with line breaks
     * @param list
     * @return 
     */
    public String listAsString(List<String> list) {
        String str = "";
        for (String string : list) {
            str += string + "\n";
        }
        return str;
    }

    /**
     * converts a list of integers to comma separated format
     * @param ints
     * @return 
     */
    public String intsToString(ArrayList<Integer> ints)
    {
        String str = "";
        // Loop over int
        for (int i = 0; i < ints.size(); i++) {
            str += ints.get(i);
            if (i < ints.size() - 1) {
                str += ", ";
            }
        }
        return str;
    }
    
    @Override
    public String toString() {
        if (insufficient) {
            return "Insufficient Species";
        }
        if (probSpecies.isEmpty()) {
            return "No Problem Species";
        }
        return intsToString(probSpecies);
    }
}
